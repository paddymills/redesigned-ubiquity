
//! Job and shipment

use std::fmt::{self, Display, Formatter};
use std::str::FromStr;
use std::sync::LazyLock;

static PATTERN_DESC: &str = "{7-digit number}{single letter}-{number}";
static JOB_SHIPMENT_PATTERN: LazyLock<regex::Regex> = LazyLock::new(|| regex::Regex::new(r"^(\d{7})([[:alpha:]]?)-(\d+)$").expect("failed to build JOB_SHIPMENT_PATTERN regex"));

/// Job number (with structure letter) and shipment
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct JobShipment {
    /// Job Number
    job: u32,
    /// Structure letter
    structure: char,
    /// Shipment
    shipment: u32
}

#[derive(Debug)]
#[cfg_attr(test, derive(PartialEq))]
pub enum JobShipmentParseError {
    // InvalidJob(String),
    // InvalidShipment(String),
    MissingStructureLetter(String),
    ExpectedPatternMismatch(String),
}

impl Display for JobShipmentParseError {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            Self::MissingStructureLetter(val) => write!(f, "Job-Shipment <{val}> is missing the structure letter"),
            Self::ExpectedPatternMismatch(val) => write!(f, "Job-Shipment <{val}> does not match expected pattern `{PATTERN_DESC}`"),
        }
    }
}

impl FromStr for JobShipment {
    type Err = JobShipmentParseError;
    
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        log::trace!("Parsing JobShipment <FromStr> {}", value);

        match JOB_SHIPMENT_PATTERN.captures(value).map(|c| c.extract()) {
            Some((full, [_, "", _])) => Err(JobShipmentParseError::MissingStructureLetter(full.into())),
            Some((_, [job, structure, ship])) => {
                
                // is this needed? regex might handle parsing errors
                let job = job.parse().unwrap();
                let structure = structure.to_uppercase().chars().nth(0).unwrap();
                let shipment = ship.parse().unwrap();

                Ok ( Self { job, structure, shipment })
            },
            _ => Err(JobShipmentParseError::ExpectedPatternMismatch(value.into()))
        }
    }
}

impl From<String> for JobShipment {
    fn from(value: String) -> Self {
        log::trace!("Parsing JobShipment <From> {}", value);
        
        Self::from_str(&value).unwrap()
    }
}

impl Display for JobShipment {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "{}{}-{}", self.job, self.structure, self.shipment)
    }
}

/// JobShipment regex tests (generated by GPT3.5)
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_valid_input() {
        assert_eq!(
            "1234567A-01".parse::<JobShipment>().unwrap(),
            JobShipment {
                job: 1234567,
                structure: 'A',
                shipment: 1
            }
        );
    }
    
    #[test]
    fn test_missing_structure_letter() {
        assert_eq!(
            "1234567-456".parse::<JobShipment>(),
            Err(JobShipmentParseError::MissingStructureLetter(String::from("1234567-456")))
        );
    }
    
    #[test]
    fn test_expected_pattern_mismatch() {
        assert_eq!(
            "1234567A-456X".parse::<JobShipment>(),
            Err(JobShipmentParseError::ExpectedPatternMismatch(String::from("1234567A-456X")))
        );
    }
}
